---
layout: post

title: 分析IBM CPLEX的python API一个自带例子
---
本文默认对cplex有一定了解。

先简单说下，API指application programming interface, 中文叫应用程序接口，意思是说，在python里装了这个API， 我们就可以通过调用cplex这个（应用）包（通过import cplex）,编写和求解模型。API相当于一个桥梁，连接cplex和python, 以cplex构造模型的方式写模型（新建objective,constraints,variables,etc.），以python方式写list,function,etc. 所以有时候你会觉得赚了，既学会了cplex又学会了python, 这是我转向api的主要动力。

说下我之前都在用啥。最初的尝试是AMPL(A Mathematical Programming Language),做优化的应该知道它，极其容易上手，解优化模型也极其方便，可是不算编程语言，更像是自然语言，总之不太有编程思维的培养。但基于它的便捷简单，我用了近一年。问题来了，AMPL的license是与具体一台电脑配对(node-based)，又不免费，所以一般只能局限在自己的电脑使用，更别提在high performance system或者Docker上用了。试试别的！接着用一个多礼拜学习了pyomo(python开发，在python中使用的优化包，类似的还有scipy）,毕竟是python平台，可以在任何机器使用啦，优点是简单易学，可以不怎么懂python，就可以写程序，如果有AMPL基础，学起来很快。但也有缺点，一是用的人不多，遇到问题找不到资料；二是开源嘛，有莫名其妙的bug；三是这个包初始化模型(也就是data loading)特别特别的慢，稍微大规模的问题，一条constraint加载时间有一个小时，很低效; 四是用多了让你变傻，与正统编程语言越来越远。说归说，这俩二货我依然在用，也很愿意与大家交流。依然在用不是放弃尝试的理由，所以今天我们一起学习学习这个API.

言归正传。

贴代码，中文是我的解释。（注：代码来自cplex安装包里自带的例子）


Here's a description of the problem: a company is considering opening as many as five warehouses in order to serve eight different regions. The goal is to minimize the sum of fixed costs associated with opening warehouses (constraint c2) as well as the various transportation costs incurred to ship goods from the warehouses to the regions (constraint c3).

----
	      
	告诉脚本用python运行该script，分两种情形：
	1.运行时如果command是python facility.py，这句代码被无视，相当于注释
	2.运行时command时 ./facility.py，该句表明解释器为python且指定python的路径
	#!/usr/bin/python

	
	# facility.py -  Model and solve a facility location problem
	# You can run this example at the command line by python facility.py 
	笔记：
	该句必须是程序首行，此时print被当做函数使用，也就是带括号
	from __future__ import print_function
	sys这个模块包含很多很多函数，备用
	import sys
	把cplex这个包导进来
	import cplex
	使用里面的exceptions,用来报错，进行flow control
	from cplex.exceptions import CplexSolverError
	
	from inputdata import read_dat_file



	def facility(datafile):
    	# Read in data file. If no file name is given on the command line
    	# we use a default file name. The data we read is
    	# capacity   -- a list/array of facility capacity
    	# fixedcost  -- a list/array of facility fixed cost
    	# cost       -- a matrix for the costs to serve each client by each
    	#               facility
    	capacity, fixedcost, cost = read_dat_file(datafile)`
		
		 笔记：
		1. len 可以得到 string, list, array,matrix等object的长度，比如len([1,2,3])=3, len("hi")=2
		 2. 多说一句，matrix可以看做多行list, 可以用numpy 建立，numpy.matrix([ [1,2], [3,4] ]) 因为是多行list,且matrix本质上也是list,所以不难理解外层的那个bracket [ ]， 我的认识是，Python里，()是跟在函数功能后面的，所以我们可以把numpy.matrix看做一个建立矩阵的函数
		 3. 对一个matrix取len,是获得其行数，如果要得到列数，可用len(cost[0])
		 4. Numpy matrices are strictly 2-dimensional, while numpy arrays (ndarrays) are N-dimensional. Matrix objects are a subclass of ndarray, so they inherit all the attributes and methods of ndarrays. The main advantage of numpy matrices is that they provide a convenient notation for matrix multiplication
		 
		 
	    num_facilities = len(fixedcost)
	    num_clients = len(cost)
	
	    # Create a new (empty) model and populate it below.
	    model = cplex.Cplex()
	
	    # Create one binary variable for each facility. The variables model
	    # whether each facility is open or not
	笔记：
		1. 注意这是新建变量的语句，要申明目标函数，上下限，类型（binary)。lb=[0] * num_facilities,是说所有变量下限都是0
		2. 假设数据给出的是有3个facilities, 这里定义的变量是x1,x2,x3,

		model.variables.add(obj=fixedcost,
	                        lb=[0] * num_facilities,
	                        ub=[1] * num_facilities,
	                        types=["B"] * num_facilities)
	
	    # Create one binary variable for each facility/client pair. The variables
	    # model whether a client is served by a facility.
	    笔记：
	    1. 假设有3个client, 那么这里定义的其实是y11,y12,y13,y21,y22,y23,y31,y32,y33
	    2. 注意这里的obj已经变化了，obj准确来说是目标函数的系数值
	    3. 到此为止，总共有12个变量，都是binary, 很明显y变量受制于x变量，会在下面的constraints中定义
	    
	    for c in range(num_clients):
	        model.variables.add(obj=cost[c],
	                            lb=[0] * num_facilities,
	                            ub=[1] * num_facilities,
	                            types=["B"] * num_facilities)
	
	
	
		下面很多是python语言
	    # Create corresponding indices for later use
	    笔记： supply是一个空的list,len(supply)=0, supply.append()说白了是填元素到这个空的list里面   
	    
	    supply = []
	    for c in range(num_clients):
	        supply.append([])
		notes：填充了一个[],supply 变成了[[]]
	        for f in range(num_facilities):
		notes: 在[]里面放进元素(0+1)*3+0=3
	            supply[c].append((c + 1) * (num_facilities) + f)
		 	    
	    # Equivalently, supply can be defined by list comprehension
	    # supply = [[(c + 1) * num_facilities + f
	    #            for f in range(num_facilities)] for c in range(num_clients)]
	
	    # Each client must be assigned to exactly one location
	    下面
	    是笔记
	    #The SparsePair class just provides another way of represting the constraint coefficients.
	    #formulated like this:
	    rows = [SparsePair(ind=[0, 1, 2], val=[-1.0, 1.0, 1.0]),
                    SparsePair(ind=[2, 3, 4], val=[-2.0, 2.0, 1.0])]
	    #the above is similar to the below expression:
	    rows = [[[0, 1, 2], [-1.0, 1.0, 1.0]],
        	   [[2, 3, 4], [-2.0, 2.0, 1.0]]]
	    #SparseTriple is similar except only useful for Cplex.quadratic_constraints.add.
	    for c in range(num_clients):
	        assignment_constraint = cplex.SparsePair(ind=[supply[c][f] for f in
	                                                      range(num_facilities)],
	                                                 val=[1.0] * num_facilities)						 
		笔记：线性constraints,申明表达式，符号E指的是=，L指less than, 等号右边的值是1	        
		model.linear_constraints.add(lin_expr=[assignment_constraint],
	                                     senses=["E"],
	                                     rhs=[1])
	
	    # The number of clients assigned to a facility must be less than the
	    # capacity of the facility, and clients must be assigned to an opened
	    # facility下面就是我们前面提到的y与x之间需要满足的关系
	    
	    for f in range(num_facilities):
	        index = [f]
	        value = [-capacity[f]]
	        for c in range(num_clients):
	            index.append(supply[c][f])
	            value.append(1.0)
		    笔记： 定义constraints是先把表达式写出来，再申明，也就是下面两条代码		    
	        capacity_constraint = cplex.SparsePair(ind=index, val=value)
	        model.linear_constraints.add(lin_expr=[capacity_constraint],
	                                     senses=["L"],
	                                     rhs=[0])
	
	    # Our objective is to minimize cost. Fixed and variable costs
	    # have been set when variables were created.
	    model.objective.set_sense(model.objective.sense.minimize)
	
	笔记：接下来是求解，用try and except查错
	    # Solve
	    try:
	        model.solve()
	    except CplexSolverError as e:
	        print("Exception raised during solve: " + e)
	    else:
	        solution = model.solution
	笔记：看print函数的使用
	        # solution.get_status() returns an integer code
	        print("Solution status = ", solution.get_status(), ":", end=' ')
	        # the following line prints the corresponding string
	        print(solution.status[solution.get_status()])
	
	        # Display solution.
	        print("Total cost = ", solution.get_objective_value())
	
	        for f in range(num_facilities):
	            if (solution.get_values(f) >                    
				model.parameters.mip.tolerances.integrality.get()):
	                print("Facility %d is open and serves the "
	                      "following clients:" % f, end=' ')
	                for c in range(num_clients):
	                    if (solution.get_values(supply[c][f]) >
          				model.parameters.mip.tolerances.integrality.get()):
	                        print(c, end=' ')
	                print()

	笔记：执行该脚本
	if __name__ == "__main__":
	    datafile = "../../../examples/data/facility.dat"
	    if len(sys.argv) < 2:
	        print("Default data file : " + datafile)
	    else:
	        datafile = sys.argv[1]
	    facility(datafile)



数据：
[ 3, 1, 2, 4, 1]
[ 480, 200, 320, 340, 300]
[[ 24, 74, 31, 51, 84], 
 [ 57, 54, 86, 61, 68],
 [ 57, 67, 29, 91, 71],
 [ 54, 54, 65, 82, 94],
 [ 98, 81, 16, 61, 27],
 [ 13, 92, 34, 94, 87],
 [ 54, 72, 41, 12, 78],
 [ 54, 64, 65, 89, 89]]
		



最后说下sys.argv,这个玩意特抽象，你可以看做一个list, 所以你看到sys.argv[1]是在用index 1提取里面的成员。sys.argv提取的第一个成员肯定是程序本身，也就是脚本名，其次才是你在命令行(command-line)输入的内容。很明显，命令行的内容来自script外部，所以sys.argv为什么被说是提取外部参数列表。





















