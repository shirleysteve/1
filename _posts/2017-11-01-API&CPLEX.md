---
layout: post

title: 分析IBM CPLEX的python API一个自带例子
---
本文默认对cplex有一定了解。

先简单说下，API指application programming interface, 中文叫应用程序接口，意思是说，在python里装了这个API， 我们就可以通过调用cplex这个（应用）包（通过import cplex）,编写和求解模型。API相当于一个桥梁，连接cplex和python, 以cplex构造模型的方式写模型（新建objective,constraints,variables,etc.），以python方式写list,function,etc. 所以有时候你会觉得赚了，既学会了cplex又学会了python, 这是我转向api的主要动力。说下我之前都在用啥。最初的尝试是AMPL(A Mathematical Programming Language),做优化的应该知道它，极其容易上手，解优化模型也极其方便，可是不算编程语言，更像是自然语言，总之不太有编程思维的培养。但基于它的便捷简单，我用了近一年。问题来了，AMPL的license是与具体一台电脑配对(node-based)，又不免费，所以一般只能局限在自己的电脑使用，更别提在high performance system或者Docker上用了。试试别的！接着用一个多礼拜学习了pyomo(python开发，在python中使用的优化包，类似的还有scipy）,毕竟是python平台，可以在任何机器使用啦，优点是简单易学，可以不怎么懂python，就可以写程序，如果有AMPL基础，学起来很快。但也有缺点，一是用的人不多，遇到问题找不到资料；二是开源嘛，有莫名其妙的bug；三是这个包初始化模型(也就是data loading)特别特别的慢，稍微大规模的问题，一条constraint加载时间有一个小时，很低效; 四是用多了让你变傻，与正统编程语言越来越远。说归说，这俩二货我依然在用，也很愿意与大家交流。依然在用不是放弃尝试的理由，所以今天我们一起学习学习这个API.

言归正传。

贴代码，中文是我的解释。（注：代码来自cplex安装包里自带的例子）

----
	
	告诉脚本用python运行该script，分两种情形：
	1.运行时如果command是python facility.py，这句代码被无视，相当于注释
	2.运行时command时 ./facility.py，该句表明解释器为python且指定python的路径
	#!/usr/bin/python

	
	# facility.py -  Model and solve a facility location problem
	# You can run this example at the command line by python facility.py 

	该句必须是程序首行，此时print被当做函数使用，也就是带括号
	from __future__ import print_function
	sys这个模块包含很多很多函数，备用
	import sys
	把cplex这个包导进来
	import cplex
	使用里面的exceptions,用来报错，进行flow control
	from cplex.exceptions import CplexSolverError
	这个。。干嘛用的，inputdata是python的包吗？！！！！
	from inputdata import read_dat_file



	def facility(datafile):
    	# Read in data file. If no file name is given on the command line
    	# we use a default file name. The data we read is
    	# capacity   -- a list/array of facility capacity
    	# fixedcost  -- a list/array of facility fixed cost
    	# cost       -- a matrix for the costs to serve each client by each
    	#               facility
    	capacity, fixedcost, cost = read_dat_file(datafile)`

	    num_facilities = len(fixedcost)
	    num_clients = len(cost)
	
	    # Create a new (empty) model and populate it below.
	    model = cplex.Cplex()
	
	    # Create one binary variable for each facility. The variables model
	    # whether each facility is open or not
	
		注意这是新建变量的语句，要申明目标函数，上下限，类型（binary)。lb=[0] * num_facilities,是说所有变量下限都是0
	    model.variables.add(obj=fixedcost,
	                        lb=[0] * num_facilities,
	                        ub=[1] * num_facilities,
	                        types=["B"] * num_facilities)
	
	    # Create one binary variable for each facility/client pair. The variables
	    # model whether a client is served by a facility.
	    for c in range(num_clients):
	        model.variables.add(obj=cost[c],
	                            lb=[0] * num_facilities,
	                            ub=[1] * num_facilities,
	                            types=["B"] * num_facilities)
	
		下面很多是python语言
	    # Create corresponding indices for later use
	    supply = []
	    for c in range(num_clients):
	        supply.append([])
	        for f in range(num_facilities):
	            supply[c].append((c + 1) * (num_facilities) + f)
	    # Equivalently, supply can be defined by list comprehension
	    # supply = [[(c + 1) * num_facilities + f
	    #            for f in range(num_facilities)] for c in range(num_clients)]
	
	    # Each client must be assigned to exactly one location
	    for c in range(num_clients):
	        assignment_constraint = cplex.SparsePair(ind=[supply[c][f] for f in
	                                                      range(num_facilities)],
	                                                 val=[1.0] * num_facilities)						 
		线性constraints,申明表达式，符号E指的是=，L指less than, 等号右边的值是1	        
		model.linear_constraints.add(lin_expr=[assignment_constraint],
	                                     senses=["E"],
	                                     rhs=[1])
	
	    # The number of clients assigned to a facility must be less than the
	    # capacity of the facility, and clients must be assigned to an open
	    # facility
	    for f in range(num_facilities):
	        index = [f]
	        value = [-capacity[f]]
	        for c in range(num_clients):
	            index.append(supply[c][f])
	            value.append(1.0)
	        capacity_constraint = cplex.SparsePair(ind=index, val=value)
	        model.linear_constraints.add(lin_expr=[capacity_constraint],
	                                     senses=["L"],
	                                     rhs=[0])
	
	    # Our objective is to minimize cost. Fixed and variable costs
	    # have been set when variables were created.
	    model.objective.set_sense(model.objective.sense.minimize)
	
	接下来是求解，用try and except查错
	    # Solve
	    try:
	        model.solve()
	    except CplexSolverError as e:
	        print("Exception raised during solve: " + e)
	    else:
	        solution = model.solution
	看print函数的使用
	        # solution.get_status() returns an integer code
	        print("Solution status = ", solution.get_status(), ":", end=' ')
	        # the following line prints the corresponding string
	        print(solution.status[solution.get_status()])
	
	        # Display solution.
	        print("Total cost = ", solution.get_objective_value())
	
	        for f in range(num_facilities):
	            if (solution.get_values(f) >                    
				model.parameters.mip.tolerances.integrality.get()):
	                print("Facility %d is open and serves the "
	                      "following clients:" % f, end=' ')
	                for c in range(num_clients):
	                    if (solution.get_values(supply[c][f]) >
          				model.parameters.mip.tolerances.integrality.get()):
	                        print(c, end=' ')
	                print()

	执行该脚本
	if __name__ == "__main__":
	    datafile = "../../../examples/data/facility.dat"
	    if len(sys.argv) < 2:
	        print("Default data file : " + datafile)
	    else:
	        datafile = sys.argv[1]
	    facility(datafile)

	
		
说下sys.argv,这个玩意特抽象，你可以看做一个list, 所以你看到sys.argv[1]是在用index 1提取里面的成员。sys.argv提取的第一个成员肯定是程序本身，也就是脚本名，其次才是你在命令行(command-line)输入的内容。很明显，命令行的内容来自script外部，所以sys.argv为什么被说是提取外部参数列表。
	
时间紧迫，我后续再过来细说。





















